---
title: "Flanker MLM Trait Relationships for Publication"
subtitle: "PD Inhibition Project"
author: "Michael Hallquist"
date: "29 May 2020"
output:
  html_document:
    code_folding: show
    df_print: default
    mathjax: default
    number_sections: no
    theme: spacelab
    toc: yes
    toc_depth: 2
    toc_float: no
    fig_width: 9 
    fig_height: 6 
  pdf_document:
    code_folding: hide
    df_print: default
    number_sections: no
    toc: yes
    toc_depth: 4
---
<style type="text/css">
body{ max-width: 2000px; margin: auto; padding: 1em; }
</style>

```{r setup, include=FALSE}
if (!require(pacman)) { install.packages("pacman"); library(pacman) }
p_load(car, nlme, lme4, readr, tidyverse, emmeans, cowplot, MplusAutomation, knitr, sas7bdat, ggcorrplot, psych, lavaan)
knitr::opts_chunk$set(echo = TRUE) #print code by default
#knitr::opts_chunk$set(cache.path = "../../Outputs/flanker_mlms/")
options(digits=3)
options(width=180)

#flanker data processed in flanker_mlm.Rmd
#has the worst subjects removed, rt_inv transformation, etc.
load("../../Data/preprocessed/flanker_for_traits.RData")
flanker <- flanker %>% mutate(rt_inv=if_else(correct==0, NA_real_, rt_inv),  #treat incorrect RTs as missing
                              prev_rt_z=as.vector(scale(prev_rt)))

#basedir <- "C:/Users/timot/Documents/GitHub/PD_Inhibition_DDM"
basedir <- "~/Data_Analysis/PD_Inhibition_DDM" 

mpq <- get(load(file.path(basedir, "Data/preprocessed/MPQ_all_scored_final.RData"))) %>% 
  filter(exclude_MPQ == 0) %>% select(subject, MPS_wbR:MPS_abR)
snap <- get(load(file.path(basedir, "Data/preprocessed/SNAP_all_scored_final.RData"))) %>% filter(exclude_SNAP == 0) %>% 
  select(subject, NEGTEMP:HDWK, DISINHP)

self_reps <- inner_join(mpq, snap, by = "subject")
```


# Initial model in Mplus (m17)

This model mimics m17 from flanker RT mlms for publication. Here, I start out with a two-level model to keep life simpler, rather than having blocks nested within subjects.


```
m17 <- lmer(rt_inv ~ cond*block + trial_z + prev_rt_z + prev_error +
              (1 + trial_z + prev_rt_z + cond + prev_error | id) +
              (1 + trial_z + run_trial_z + prev_rt_z | id:block),
          na.action = na.exclude, control=lmerControl(optCtrl=list(maxfun=2e4)), #bump up iterations
          data = flanker, REML=FALSE) # control=lmerControl(optimizer = "nlminbwrap"))

```

```{r m17_mplus, cache=TRUE}
m17_mplus <- mplusObject(
  TITLE = "Equivalent model to lmer m17",
  DEFINE = "
    cond = cond - 1; ! 0=congruent, 1=incongruent
    block = block - 1; ! 0=most_incon, 1=most_con
    cond_block = cond*block; ! 1=most_con, incongruent
  ",
  VARIABLE = "
    WITHIN = cond block cond_block prev_rt_z prev_error trial_z run_trial_z;
    USEVARIABLES = id rt_inv cond block prev_rt_z 
      prev_error trial_z run_trial_z cond_block;
    CLUSTER = id;
  ",
  ANALYSIS = "
    TYPE=TWOLEVEL RANDOM;
    ESTIMATOR=BAYES;
    BITERATIONS=(10000);
    CHAINS=2;
    PROCESSORS=4;
  ",
  MODEL = "
    %WITHIN%
    rt_inv ON block cond_block;
    condslo | rt_inv ON cond;        !random slope of cond
    runslo | rt_inv ON run_trial_z;  !random slope of run_trial
    trialslo | rt_inv ON trial_z;    !random slope of trial
    prevslo | rt_inv ON prev_rt_z;   !random slope of rt autocorrelation
    errslo | rt_inv ON prev_error;   !random slope of previous error
    
    %BETWEEN%
    !means of random slopes
    [condslo];
    [runslo];
    [trialslo];
    [prevslo];
    [errslo];
    
    !variances of random slopes
    condslo;
    runslo;
    trialslo;
    prevslo;
    errslo;
    
    !slope correlations
    condslo runslo trialslo prevslo errslo WITH
       condslo runslo trialslo prevslo errslo;
    
    [rt_inv]; !mean average inverse RT
  ",
  PLOT = "TYPE = PLOT2;",
  OUTPUT = "TECH1 TECH8 STANDARDIZED CINTERVAL;",
  rdata = flanker
)

mout <- mplusModeler(m17_mplus, dataout="flanker_mplus.dat", 
                        modelout="m17_mplus.inp", run=TRUE, Mplus_command = "~/Applications/Mplus/mplus")

results <- mout$results

```

# Consider dropping run_trial since it has little variation and zero mean

Turns out that DIC is 9 points lower for the model that keeps run_trial in the mix.

```{r m17_mplus_noruntrial, cache=TRUE}
m17_mplus_noruntrial <- mplusObject(
  TITLE = "Equivalent model to lmer m17, drop run_trial",
  DEFINE = "
    cond = cond - 1; ! 0=congruent, 1=incongruent
    block = block - 1; ! 0=most_incon, 1=most_con
    cond_block = cond*block; ! 1=most_con, incongruent
  ",
  VARIABLE = "
    WITHIN = cond block cond_block prev_rt_z prev_error trial_z;
    USEVARIABLES = id rt_inv cond block prev_rt_z 
      prev_error trial_z cond_block;
    CLUSTER = id;
  ",
  ANALYSIS = "
    TYPE=TWOLEVEL RANDOM;
    ESTIMATOR=BAYES;
    BITERATIONS=(10000);
    CHAINS=2;
    PROCESSORS=4;
  ",
  MODEL = "
    %WITHIN%
    rt_inv ON block cond_block;
    condslo | rt_inv ON cond;        !random slope of cond
    trialslo | rt_inv ON trial_z;    !random slope of trial
    prevslo | rt_inv ON prev_rt_z;   !random slope of rt autocorrelation
    errslo | rt_inv ON prev_error;   !random slope of previous error
    
    %BETWEEN%
    !means of random slopes
    [condslo];
    [trialslo];
    [prevslo];
    [errslo];
    
    !variances of random slopes
    condslo;
    trialslo;
    prevslo;
    errslo;
    
    !slope correlations
    condslo trialslo prevslo errslo WITH
       condslo trialslo prevslo errslo;
    
    [rt_inv]; !mean average inverse RT
  ",
  PLOT = "TYPE = PLOT2;",
  OUTPUT = "TECH1 TECH8 STANDARDIZED CINTERVAL;",
  rdata = flanker
)

mout <- mplusModeler(m17_mplus_noruntrial, dataout="flanker_mplus.dat", 
                        modelout="m17_mplus_noruntrial.inp", run=TRUE, Mplus_command = "~/Applications/Mplus/mplus")

results <- mout$results

```

# Middle ground, keep run_trial as fixed effect at L1

Still worse

```{r m17_mplus_fixedruntrial, cache=TRUE}
m17_mplus_fixedruntrial <- mplusObject(
  TITLE = "Equivalent model to lmer m17, drop run_trial",
  DEFINE = "
    cond = cond - 1; ! 0=congruent, 1=incongruent
    block = block - 1; ! 0=most_incon, 1=most_con
    cond_block = cond*block; ! 1=most_con, incongruent
  ",
  VARIABLE = "
    WITHIN = cond block cond_block prev_rt_z prev_error trial_z run_trial_z;
    USEVARIABLES = id rt_inv cond block prev_rt_z 
      prev_error trial_z run_trial_z cond_block;
    CLUSTER = id;
  ",
  ANALYSIS = "
    TYPE=TWOLEVEL RANDOM;
    ESTIMATOR=BAYES;
    BITERATIONS=(10000);
    CHAINS=2;
    PROCESSORS=4;
  ",
  MODEL = "
    %WITHIN%
    rt_inv ON block cond_block run_trial_z;
    condslo | rt_inv ON cond;        !random slope of cond
    trialslo | rt_inv ON trial_z;    !random slope of trial
    prevslo | rt_inv ON prev_rt_z;   !random slope of rt autocorrelation
    errslo | rt_inv ON prev_error;   !random slope of previous error
    
    %BETWEEN%
    !means of random slopes
    [condslo];
    [trialslo];
    [prevslo];
    [errslo];
    
    !variances of random slopes
    condslo;
    trialslo;
    prevslo;
    errslo;
    
    !slope correlations
    condslo trialslo prevslo errslo WITH
       condslo trialslo prevslo errslo;
    
    [rt_inv]; !mean average inverse RT
  ",
  PLOT = "TYPE = PLOT2;",
  OUTPUT = "TECH1 TECH8 STANDARDIZED CINTERVAL;",
  rdata = flanker
)

mout <- mplusModeler(m17_mplus_fixedruntrial, dataout="flanker_mplus.dat", 
                        modelout="m17_mplus_fixedruntrial.inp", run=TRUE, Mplus_command = "~/Applications/Mplus/mplus")

results <- mout$results

```


# Prune a few tiny runslo covariances in the between model

Tried to prune runslo relationship with trialslo and condslo. This throws the dreaded:

```
*** FATAL ERROR
     THE VARIANCE COVARIANCE MATRIX IS NOT SUPPORTED.
     ONLY FULL VARIANCE COVARIANCE BLOCKS ARE ALLOWED.
     USE ALGORITHM=GIBBS(RW) OR ALGORITHM=MH TO RESOLVE THIS PROBLEM.
```

Thus, stick with full m17 above.

# Antagonism MSEM

Replicate parceling approach from Trait_Structure RMD file.

Here are the couplets:

1. MISTRUST (Mistrustfulness) and MPS_alr (Alienation)
2. PROPER (Propriety) and MPS_tdr (Traditionalism)
3. IMPUL (Impulsivity, reversed) and MPS_clr (Control)
4. HDWK (Hard-working) and MPS_acr (Achievement)
5. AGG (Aggression) and MPS_agr (Aggression)

```{r}
tofactor <- self_reps %>% select(subject, MPS_agR, AGG, MISTRUST, MPS_alR, MANIP,
      PROPER, MPS_clR, IMPUL, MPS_tdR, MPS_acR, HDWK) %>% 
  mutate(IMPUL =-1*IMPUL) %>% #score toward constraint to make loadings upright
  mutate_at(vars(-subject), list(~as.vector(scale(.)))) %>%
  dplyr::rename(id=subject)

for_msem <- flanker %>% inner_join(tofactor, by="id")
anti_join(tofactor, flanker, by="id")
```

Note that the four IDs excluded from flanker all have valid self-report data. But 7 good flanker subjects have bad self-report data, I think. Thus, we move to a sample of 100 total for the combined analysis.

ID 44 appears to be missing flanker data altogether (even in original excel file)

```{r}
length(unique(for_msem))
```

```{r antag, cache=TRUE}
AC_msem <- mplusObject(
  TITLE="Antagonism and Disinhibition BSEM CFA 3+3 Parcels, Flanker RT",
  DEFINE="
    p1=MEAN(MISTRUST MPS_alR);
    p2=MEAN(PROPER MPS_tdR);
    p3=MEAN(MPS_clR IMPUL);
    p4=MEAN(MPS_acR HDWK);
    p5=MEAN(MPS_agR AGG);
    cond = cond - 1; ! 0=congruent, 1=incongruent
    block = block - 1; ! 0=most_incon, 1=most_con
    cond_block = cond*block; ! 1=most_con, incongruent
  ",
  
  VARIABLE = "
    WITHIN = cond block cond_block prev_rt_z prev_error trial_z run_trial_z;
    USEVARIABLES = id rt_inv cond block prev_rt_z 
      prev_error trial_z run_trial_z
      MANIP p1 p2 p3 p4 p5 cond_block;
    BETWEEN = MANIP p1 p2 p3 p4 p5;
    CLUSTER = id;
  ",
  ANALYSIS = "
    TYPE=TWOLEVEL RANDOM;
    ESTIMATOR=BAYES;
    BITERATIONS=(15000);
    CHAINS=2;
    PROCESSORS=4;
  ",
  MODEL = "
  
  %WITHIN%
    rt_inv ON block cond_block;
    condslo | rt_inv ON cond;        !random slope of cond
    prevslo | rt_inv ON prev_rt_z;   !random slope of rt autocorrelation
    errslo | rt_inv ON prev_error;   !random slope of previous error
    runslo | rt_inv ON run_trial_z;  !random slope of run_trial
    trialslo | rt_inv ON trial_z;    !random slope of trial

    
  %BETWEEN%
    !means of random slopes
    [condslo];
    [runslo];
    [trialslo];
    [prevslo];
    [errslo];
    
    !variances of random slopes
    condslo;
    runslo;
    trialslo;
    prevslo;
    errslo;
    
    !slope correlations
    condslo runslo trialslo prevslo errslo WITH
       condslo runslo trialslo prevslo errslo;
    
    [rt_inv]; !mean average inverse RT
    
    !TRAIT MODEL
        
    antag BY p5 ! MPS_agR AGG
      p1        ! MISTRUST MPS_alR
      MANIP;

    inhib BY
      p2  !PROPER MPS_tdR
      p3  !MPS_clR IMPUL
      p4; !MPS_acR HDWK;

    antag WITH inhib;

    !TRAIT MODERATION
    
    ! trait moderates flanker performance -- incongruency effect and stickiness of RT
    condslo ON antag inhib;
    prevslo ON antag inhib;
    
    !errslo ON antag inhib; !highly non-significant
    
    !N.B. Leaving out the association of antag with rt_inv 
    !omits a hugely important relationship.
    !Thus, allow antag as a predictor of average (person) RT
    rt_inv ON antag inhib;
  ",
  # SAVEDATA = "
  #   FILE = AC_bsem_cfa_parcel_fscores.dat;
  #   SAVE = FSCORES(5000);
  # ",
  PLOT = "TYPE = PLOT2;",
  OUTPUT ="
    TECH1 TECH8 STANDARDIZED CINTERVAL;
  ",
  rdata=for_msem
)
 
mres <- mplusModeler(AC_msem, modelout = file.path("AC_flanker_msem_parcel.inp"), 
                     hashfilename = FALSE, run=TRUE,
                     Mplus_command = "/Users/mnh5174/Applications/Mplus/mplus")

summary(mres)
kable(mres$results$parameters$stdyx.standardized %>% 
        filter(!paramHeader %in% c("Intercepts", "Means", "Residual Variances")))
```

# Dominance MSEM

Here is the full model from the between-person analysis in Trait_Structure. It gets very finicky, though, basically sending the model off the rails. On further examination, both in the parceled model and the full indicator model, the problem emerges primarily from having a fixed factor loading for identification (unit loading identification). When we switch to unit variance identification (standardizing the factor), the model converges very nicely (even with very high iterations). Thus, switch to this identification approach for estimability.

For the full model, I get an Mplus error 

```
*** FATAL ERROR

     STANDARDIZED COEFFICIENTS ARE NOT AVAILABLE FOR THIS MODEL.
     THIS CAN BE RESOLVED BY ADDING REGRESSION ON STATEMENTS FOR ALL DEPENDENT VARIABLES.
```

I've turned off standardized output for now. I think it's due to the residual correlation in the factor.

```{r}
tofactor <- self_reps %>% dplyr::select(subject, POSTEMP, EXHIB, ENTITL, DETACH, MPS_wbR, MPS_spR, MPS_scR) %>%
  mutate(MPS_scR=-1*MPS_scR) %>% #rescore in direction of detachment (higher scores are bad)
  mutate_at(vars(-subject), list(~as.vector(scale(.)))) %>%
  dplyr::rename(id=subject)

for_msem <- flanker %>% inner_join(tofactor, by="id")
anti_join(tofactor, flanker, by="id")
```

```{r dom, cache=TRUE}

Dom_msem <- mplusObject(
  TITLE="Dominance and Detachment MSEM Flanker RT",
  DEFINE="
    cond = cond - 1; ! 0=congruent, 1=incongruent
    block = block - 1; ! 0=most_incon, 1=most_con
    cond_block = cond*block; ! 1=most_con, incongruent
  ",
  
  VARIABLE = "
    WITHIN = cond block cond_block prev_rt_z prev_error trial_z run_trial_z;
    USEVARIABLES = id rt_inv cond block prev_rt_z 
      prev_error trial_z run_trial_z
      POSTEMP EXHIB ENTITL DETACH MPS_wbR MPS_spR MPS_scR cond_block;
    BETWEEN = POSTEMP EXHIB ENTITL DETACH MPS_wbR MPS_spR MPS_scR;
    CLUSTER = id;
  ",
  ANALYSIS = "
    TYPE=TWOLEVEL RANDOM;
    ESTIMATOR=BAYES;
    BITERATIONS=(20000);
    CHAINS=4;
    PROCESSORS=4;
  ",
  MODEL = "
  
  %WITHIN%
    rt_inv ON block cond_block;
    condslo | rt_inv ON cond;        !random slope of cond
    prevslo | rt_inv ON prev_rt_z;   !random slope of rt autocorrelation
    errslo | rt_inv ON prev_error;   !random slope of previous error
    runslo | rt_inv ON run_trial_z;  !random slope of run_trial
    trialslo | rt_inv ON trial_z;    !random slope of trial

    
  %BETWEEN%
    !means of random slopes
    [condslo];
    [runslo];
    [trialslo];
    [prevslo];
    [errslo];
    
    !variances of random slopes
    condslo;
    runslo;
    trialslo;
    prevslo;
    errslo;
    
    !slope correlations
    condslo runslo trialslo prevslo errslo WITH
       condslo runslo trialslo prevslo errslo;
    
    [rt_inv]; !mean average inverse RT
    
    !TRAIT MODEL
    agentic BY MPS_spR* EXHIB ENTITL POSTEMP MPS_wbR;
    agentic@1;
    
    affiliat BY MPS_scR*1 DETACH;
    affiliat@1;
    
    agentic WITH affiliat;
    MPS_SPR WITH EXHIB;
    !DETACH@0;  !heywood case in MLR, okay in Bayes (force positive variance)

    !TRAIT MODERATION
    
    ! trait moderates flanker performance -- incongruency effect and stickiness of RT
    condslo ON agentic affiliat;
    prevslo ON agentic affiliat;
    
    errslo ON agentic affiliat;
    
    !N.B. Leaving out the association of antag with rt_inv 
    !omits a hugely important relationship.
    !Thus, allow antag as a predictor of average (person) RT
    rt_inv ON agentic affiliat;
  ",
  # SAVEDATA = "
  #   FILE = AC_bsem_cfa_parcel_fscores.dat;
  #   SAVE = FSCORES(5000);
  # ",
  PLOT = "TYPE = PLOT2;",
  OUTPUT ="
    TECH1 TECH8 CINTERVAL;
  ",
  rdata=for_msem
)
 
mres <- mplusModeler(Dom_msem, modelout = file.path("Dom_flanker_rt_msem.inp"), 
                     hashfilename = FALSE, run=TRUE,
                     Mplus_command = "/Users/mnh5174/Applications/Mplus/mplus")

summary(mres)
kable(mres$results$parameters$unstandardized %>% 
        filter(!paramHeader %in% c("Intercepts", "Means", "Residual Variances")))
```

## Parcel model

The parcel model goes off the rails if we fix the first loading to one, particularly for the (dis)affiliative factor. But if we standardize the factors manually, it will converge without issue (even running the chains out twice as long).

```{r dom_parcel, cache=TRUE}

Dom_msem_parcel <- mplusObject(
  TITLE="Dominance and Detachment MSEM Flanker RT Parcel",
  DEFINE="
    p1 = MEAN(MPS_spR EXHIB);
    p2 = MEAN(POSTEMP MPS_wbR);
    cond = cond - 1; ! 0=congruent, 1=incongruent
    block = block - 1; ! 0=most_incon, 1=most_con
    cond_block = cond*block; ! 1=most_con, incongruent
  ",
  
  VARIABLE = "
    WITHIN = cond block cond_block prev_rt_z prev_error trial_z run_trial_z;
    USEVARIABLES = id rt_inv cond block prev_rt_z 
      prev_error trial_z run_trial_z
      ENTITL DETACH MPS_scR p1 p2 cond_block;
    BETWEEN = ENTITL DETACH MPS_scR p1 p2;
    CLUSTER = id;
  ",
  ANALYSIS = "
    TYPE=TWOLEVEL RANDOM;
    ESTIMATOR=BAYES;
    BITERATIONS=(20000);
    CHAINS=4;
    PROCESSORS=4;
  ",
  MODEL = "
  
  %WITHIN%
    rt_inv ON block cond_block;
    condslo | rt_inv ON cond;        !random slope of cond
    prevslo | rt_inv ON prev_rt_z;   !random slope of rt autocorrelation
    errslo | rt_inv ON prev_error;   !random slope of previous error
    runslo | rt_inv ON run_trial_z;  !random slope of run_trial
    trialslo | rt_inv ON trial_z;    !random slope of trial

  %BETWEEN%
    !means of random slopes
    [condslo];
    [runslo];
    [trialslo];
    [prevslo];
    [errslo];
    
    !variances of random slopes
    condslo;
    runslo;
    trialslo;
    prevslo;
    errslo;
    
    !slope correlations
    condslo runslo trialslo prevslo errslo WITH
       condslo runslo trialslo prevslo errslo;
    
    [rt_inv]; !mean average inverse RT
    
    !TRAIT MODEL
    
    agentic BY p1*1 !MPS_spR EXHIB
      p2 !POSTEMP MPS_wbR
      ENTITL;
      
    agentic@1;
  
    affiliat BY MPS_scR*1 DETACH;
    affiliat@1;
    
    agentic WITH affiliat;
    
    !TRAIT MODERATION
    
    ! trait moderates flanker performance -- incongruency effect and stickiness of RT
    condslo ON agentic affiliat;
    prevslo ON agentic affiliat;
    errslo ON agentic affiliat;
    
    !N.B. Leaving out the association of antag with rt_inv 
    !omits a hugely important relationship.
    !Thus, allow antag as a predictor of average (person) RT
    rt_inv ON agentic affiliat;
  ",
  PLOT = "TYPE = PLOT2;",
  OUTPUT ="
    TECH1 TECH8 CINTERVAL STANDARDIZED;
  ",
  rdata=for_msem
)
 
mres <- mplusModeler(Dom_msem_parcel, modelout = file.path("Dom_flanker_rt_msem_parcel.inp"), 
                     hashfilename = FALSE, run=TRUE,
                     Mplus_command = "/Users/mnh5174/Applications/Mplus/mplus")

summary(mres)
kable(mres$results$parameters$unstandardized %>% 
        filter(!paramHeader %in% c("Intercepts", "Means", "Residual Variances")))
```